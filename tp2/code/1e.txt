    CALL main           ; Salta al programa principal
    HLT

output: DB 0xE8         ; Posición del cursor
dato:   DB 5            ; Dato

main:                   ; Programa principal
    DEC SP              ; Alocamos 1 byte para factorial(n)
    PUSH [dato]         ; Argumento 'n' al stack
    CALL printNo        ; Llamamos a printNo(n)
    MOV [SP+1], '!'     ; Argumento exclm al stack
    CALL printChar      ; Llamamos a print(exclm)
    MOV [SP+1], '='     ; Argumento equal al stack
    CALL printChar      ; Llamamos a print(equal)
    INC SP              ; Sacamos argumento del stack
    PUSH [dato]         ; Argumento 'n' al stack
    CALL factorial      ; Calculamos el factorial
    MOV [SP+1], '='      ; Argumento equal al stack
    CALL printChar      ; Llamamos a print(equal)
    INC SP              ; Sacamos argumento del stack
    CALL printNo        ; Llamamos a printNo(n!)
    INC SP              ; Liberamos memoria
    RET

factorial:              ; factorial(n) como función recursiva
    PUSH [SP+2]         ; Argumento 'n' al stack
    MOV A, [SP+1]       ; Argumento 'n' a registro A
    CMP A, 0            ; Comparamos 'n' con 0
    JZ base             ; Si 'n' == 0, saltamos a base
    CMP A, 1            ; Comparamos 'n' con 1
    JZ base             ; Si 'n' == 1, saltamos a base
    CALL printNo        ; Llamamos a printNo(n)
    MOV [SP+1], '×'     ; Argumento times al stack
    CALL printChar      ; Llamamos a print(times)
    MOV A, [SP+3]       ; Argumento 'n' a registro A
    DEC A               ; Decrementamos 'n'
    PUSH A              ; Argumento 'n-1' al stack
    CALL factorial      ; Llamamos a factorial(n-1)
    INC SP              ; Sacamos argumento del stack
    MOV A, [SP+1]       ; Resultado de factorial(n-1) a A
    MOV B, [SP+3]       ; Argumento 'n' a B
    MUL B               ; Multiplicar n*(n-1)!
    MOV [SP+4], A       ; Resultado a valor de retorno
    INC SP              ; Liberamos memoria
    RET
base:
    MOV [SP+1], 1       ; Argumento '1' al stack
    CALL printNo        ; Llamamos a print(1)
    MOV [SP+4], 1       ; Si es cero, 1 a valor de retorno
    INC SP              ; Liberamos memoria
    RET

printNo:                ; Imprime un número
    MOV D, [output]
    MOV B, [SP+2]
    MOV A, B
    DIV 100             ; Calculo dígito 1
    MOV C, A
    JZ skip1            ; Si dígito 1 es 0, saltamos
    ADD C, 48           ; Paso dígito 1 a ASCII
    MOV [D], C          ; Paso dígito 1 al output
    INC D               ; Incremento cursor
skip1:
    MUL 100
    SUB B, A
    MOV A, B
    DIV 10              ; Calculo dígito 2
    OR C, A
    JZ skip2            ; Si dígitos 1 y 2 son 0, saltamos
    MOV C, A
    ADD C, 48           ; Paso dígito 2 a ASCII
    MOV [D], C          ; Paso dígito 2 al output
    INC D               ; Incremento cursor
skip2:
    MUL 10
    SUB B, A            ; Calculo dígito 3
    ADD B, 48           ; Paso dígito 3 a ASCII
    MOV [D], B          ; Paso dígito 3 al output
    INC D               ; Incremento cursor
    MOV [output], D     ; Actualizo cursor
    RET

printChar:              ; Imprime un caracter
    MOV D, [output]     ; Posición cursor a D
    MOV C, [SP+2]	; Caracter a C
    MOV [D], C          ; Caracter al output
    INC D               ; Incremento cursor
    MOV [output], D     ; Actualizo cursor
    RET